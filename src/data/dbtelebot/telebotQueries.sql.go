// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: telebotQueries.sql

package dbtelebot

import (
	"context"
	"database/sql"
)

const deleteAnswersOfClient = `-- name: DeleteAnswersOfClient :exec
update client_has_questions set state=0 where client_id = ?
`

func (q *Queries) DeleteAnswersOfClient(ctx context.Context, clientID int32) error {
	_, err := q.exec(ctx, q.deleteAnswersOfClientStmt, deleteAnswersOfClient, clientID)
	return err
}

const getClientByTelegramUserId = `-- name: GetClientByTelegramUserId :one
select id, name, chat_id, telegram_user_id, waiting_for_answer, questions_id from client where telegram_user_id = ?
`

func (q *Queries) GetClientByTelegramUserId(ctx context.Context, telegramUserID string) (Client, error) {
	row := q.queryRow(ctx, q.getClientByTelegramUserIdStmt, getClientByTelegramUserId, telegramUserID)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ChatID,
		&i.TelegramUserID,
		&i.WaitingForAnswer,
		&i.QuestionsID,
	)
	return i, err
}

const getClientScore = `-- name: GetClientScore :one
select concat(sum(if(o.is_correct=1,10,0))) puntaje from client_has_questions cqa
left join ` + "`" + `options` + "`" + ` o on cqa.options_id = o.id
 where state=1 and client_id = ?
 group by cqa.client_id
`

func (q *Queries) GetClientScore(ctx context.Context, clientID int32) (string, error) {
	row := q.queryRow(ctx, q.getClientScoreStmt, getClientScore, clientID)
	var puntaje string
	err := row.Scan(&puntaje)
	return puntaje, err
}

const getOneRandomNotAnsweredQuestion = `-- name: GetOneRandomNotAnsweredQuestion :one
select q.id, q.question from questions q 
left join client_has_questions cqa on cqa.questions_id = q.id and cqa.state=1 and cqa.client_id=?
where cqa.questions_id is null
order by rand() limit 1
`

func (q *Queries) GetOneRandomNotAnsweredQuestion(ctx context.Context, clientID int32) (Question, error) {
	row := q.queryRow(ctx, q.getOneRandomNotAnsweredQuestionStmt, getOneRandomNotAnsweredQuestion, clientID)
	var i Question
	err := row.Scan(&i.ID, &i.Question)
	return i, err
}

const getOptionByQuestionIdAndText = `-- name: GetOptionByQuestionIdAndText :one
select id, ` + "`" + `option` + "`" + `, questions_id, is_correct from options where questions_id = ? and ` + "`" + `option` + "`" + ` = ?
`

type GetOptionByQuestionIdAndTextParams struct {
	QuestionsID int32
	Text        string
}

func (q *Queries) GetOptionByQuestionIdAndText(ctx context.Context, arg GetOptionByQuestionIdAndTextParams) (Option, error) {
	row := q.queryRow(ctx, q.getOptionByQuestionIdAndTextStmt, getOptionByQuestionIdAndText, arg.QuestionsID, arg.Text)
	var i Option
	err := row.Scan(
		&i.ID,
		&i.Option,
		&i.QuestionsID,
		&i.IsCorrect,
	)
	return i, err
}

const getOptionsByQuestionId = `-- name: GetOptionsByQuestionId :many
select id, ` + "`" + `option` + "`" + `, questions_id, is_correct from options where questions_id = ?
`

func (q *Queries) GetOptionsByQuestionId(ctx context.Context, questionsID int32) ([]Option, error) {
	rows, err := q.query(ctx, q.getOptionsByQuestionIdStmt, getOptionsByQuestionId, questionsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Option
	for rows.Next() {
		var i Option
		if err := rows.Scan(
			&i.ID,
			&i.Option,
			&i.QuestionsID,
			&i.IsCorrect,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionById = `-- name: GetQuestionById :one
select id, question from questions where id = ?
`

func (q *Queries) GetQuestionById(ctx context.Context, id int32) (Question, error) {
	row := q.queryRow(ctx, q.getQuestionByIdStmt, getQuestionById, id)
	var i Question
	err := row.Scan(&i.ID, &i.Question)
	return i, err
}

const getReferencesByQuestionId = `-- name: GetReferencesByQuestionId :many
select id, name, text, questions_id from ` + "`" + `references` + "`" + ` where questions_id = ?
`

func (q *Queries) GetReferencesByQuestionId(ctx context.Context, questionsID int32) ([]Reference, error) {
	rows, err := q.query(ctx, q.getReferencesByQuestionIdStmt, getReferencesByQuestionId, questionsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reference
	for rows.Next() {
		var i Reference
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Text,
			&i.QuestionsID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTheLastQuestionAnsweredByClient = `-- name: GetTheLastQuestionAnsweredByClient :one
select client_id, questions_id, options_id, date, state from client_has_questions where client_id = ? 
and state=1 order by date desc limit 1
`

func (q *Queries) GetTheLastQuestionAnsweredByClient(ctx context.Context, clientID int32) (ClientHasQuestion, error) {
	row := q.queryRow(ctx, q.getTheLastQuestionAnsweredByClientStmt, getTheLastQuestionAnsweredByClient, clientID)
	var i ClientHasQuestion
	err := row.Scan(
		&i.ClientID,
		&i.QuestionsID,
		&i.OptionsID,
		&i.Date,
		&i.State,
	)
	return i, err
}

const insertClient = `-- name: InsertClient :exec
insert into 
client (name, chat_id, telegram_user_id, waiting_for_answer, questions_id) 
values (?, ?, ?, ?, ?)
`

type InsertClientParams struct {
	Name             string
	ChatID           string
	TelegramUserID   string
	WaitingForAnswer interface{}
	QuestionsID      sql.NullInt32
}

func (q *Queries) InsertClient(ctx context.Context, arg InsertClientParams) error {
	_, err := q.exec(ctx, q.insertClientStmt, insertClient,
		arg.Name,
		arg.ChatID,
		arg.TelegramUserID,
		arg.WaitingForAnswer,
		arg.QuestionsID,
	)
	return err
}

const insertClientHasQuestions = `-- name: InsertClientHasQuestions :exec
insert into
client_has_questions (client_id, questions_id, options_id, date, state)
values (?, ?, ?, now(), 1)
`

type InsertClientHasQuestionsParams struct {
	ClientID    int32
	QuestionsID int32
	OptionsID   int32
}

func (q *Queries) InsertClientHasQuestions(ctx context.Context, arg InsertClientHasQuestionsParams) error {
	_, err := q.exec(ctx, q.insertClientHasQuestionsStmt, insertClientHasQuestions, arg.ClientID, arg.QuestionsID, arg.OptionsID)
	return err
}

const setClientWaitingForAnswer = `-- name: SetClientWaitingForAnswer :exec
update client set waiting_for_answer = ?, questions_id=? where id = ?
`

type SetClientWaitingForAnswerParams struct {
	WaitingForAnswer interface{}
	QuestionAskedID  sql.NullInt32
	ID               int32
}

func (q *Queries) SetClientWaitingForAnswer(ctx context.Context, arg SetClientWaitingForAnswerParams) error {
	_, err := q.exec(ctx, q.setClientWaitingForAnswerStmt, setClientWaitingForAnswer, arg.WaitingForAnswer, arg.QuestionAskedID, arg.ID)
	return err
}

const setClientWaitingForAnswerToFalse = `-- name: SetClientWaitingForAnswerToFalse :exec
update client set waiting_for_answer = 0 where id = ?
`

func (q *Queries) SetClientWaitingForAnswerToFalse(ctx context.Context, id int32) error {
	_, err := q.exec(ctx, q.setClientWaitingForAnswerToFalseStmt, setClientWaitingForAnswerToFalse, id)
	return err
}

const setClientWaitingForAnswerToTrueAndQuestionId = `-- name: SetClientWaitingForAnswerToTrueAndQuestionId :exec
update client set waiting_for_answer = 1, questions_id = ? where id = ?
`

type SetClientWaitingForAnswerToTrueAndQuestionIdParams struct {
	QuestionsID sql.NullInt32
	ClientID    int32
}

func (q *Queries) SetClientWaitingForAnswerToTrueAndQuestionId(ctx context.Context, arg SetClientWaitingForAnswerToTrueAndQuestionIdParams) error {
	_, err := q.exec(ctx, q.setClientWaitingForAnswerToTrueAndQuestionIdStmt, setClientWaitingForAnswerToTrueAndQuestionId, arg.QuestionsID, arg.ClientID)
	return err
}
